classdef wSubmerged < handle
    properties
        H = 5;                    % Submerge depth
        k = 1;                    % Wavenumber
        Fr2 = 2.25;               % Squared Froude number
        h = 6;                    % Truncation height
        N = 400;                  % Number of collocation points
    end
    properties (SetAccess = private)
        Re = inf;                 % Reynolds number
        zc;                       % Critical height
        subD; subDclass;          % Subdomains and its corresponding class function 
        method;                   % Numerical methods, set by @numMeth
        ord;                      % Order of GE, 2 for Rayleigh, 4 for Orr-Sommerfeld
        dm;                       % Differential matrix constructing method (function handle)
        baseflow;                 % Velocity profile (function handle)
        invbf;                    % Inverse function of base flow (function handle)
    end
    methods
        function obj = wSubmerged(N,H,k,h,Re,Fr2,bf)
            if (nargin >= 6)
                obj.N = N; obj.k = k; obj.h = h; obj.Re = Re;
                obj.Fr2 = Fr2; obj.H = H; 
                obj.setbaseflow(bf);
            end
            obj.method = strings(1,2);
        end
        % Solve the stability equations of the flow
        [c, an, cA, errGEP, dob] = solver(obj, alg, des, bal, eigspec, funcN, addvar);
        [c, an, cA, errGEP, dob] = solver2(obj, alg, des, bal, eigspec, funcN, addvar);
        [c, an, ca, ana] = solver_RE(obj, alg, des, bal, eigspec, funcN, addvar)
        % Select the discretizing strategy (meth, ord, dm)
        numMeth(obj,meth);
        % Return chosen properties of the flow
        function [out,varargout] = getprop(obj,prop,varargin)
            switch lower(prop)
            case 'u' % out:[z,U] 
                % Return the baseflow collocation points
                out = []; U = [];
                for i = 1:length(obj.subD)
                    out = [out;obj.subD(i).z];
                    U = [U;obj.subD(i).U];
                end
                varargout{1} = U;
            case 'cut' % out:cut positions
                % Return the domain decomposed locations
                out = nan(1,length(obj.subD)+1);
                for i = 1:length(obj.subD)
                    out(i) = obj.subD(i).ztop;
                end
                out(i+1) = obj.subD(end).zbot;
            case 'modeshape' % in:eigenvector, out:[z,phi] 
                an = varargin{1};
                num = 0; out = []; phi = [];
                for i = 1:length(obj.subD)
                    out = [out;obj.subD(i).z];
                    phi = [phi;obj.subD(i).modeshape(an(num+1:num+obj.subD(i).N+1))];
                    num = num + obj.subD(i).N + 1;
                end
                varargout{1} = phi;
            otherwise
                error('Invalid input for function getprop()');
            end
        end
        % Set properties of the flow
        function setprop(obj,varargin)
            if (mod(length(varargin),2) == 1 || isempty(varargin))
                error('Invalid number of inputs.');
            end
            nam = varargin(1:2:end);
            val = varargin(2:2:end);
            for i = 1:length(nam)
                switch nam{i}
                case 'Re'
                    obj.Re = val{i};
                    if isinf(val{i})
                        obj.method(1) = "Ray";
                        obj.subDclass = @subRay;
                        obj.ord = 2;
                    else
                        obj.method(1) = "d4";
                        obj.subDclass = @subOrr;
                        obj.ord = 4;
                    end
                    obj.subD = obj.subDclass(); % initialize
                case 'method'
                    obj.numMeth(val{i});
                case 'baseflow'
                    obj.setbaseflow(val{i});
                otherwise
                    if isprop(obj,nam{i})
                        obj.(nam{i}) = val{i};
                    else
                        error('Invalid property name.');
                    end
                end
            end
        end
    end
    methods (Static)
        % Select the domain decomposition strategy (f)
        out = ddmtype(name);
    end
    methods (Access = private)
        % Construct matrix A, B for the GEP
        function [A, B] = makeAB(obj)
            % Governing equation
            [Age, Bge] = obj.subD(1).match(obj.subD);
            % BC (truncated, free surface)
            [Abc1, Bbc1] = obj.subD(1).BC0(size(Age,2)-1);
            % BC (truncated, exponential decay)
            [Abc2, Bbc2] = obj.subD(end).BChe(size(Age,2)-1);
            A = [Age; Abc1; Abc2];
            B = [Bge; Bbc1; Bbc2];    
        end
        function [A, B] = makeAB2(obj)
            % Governing equation
            [Age, Bge] = obj.subD(1).match(obj.subD);
            % BC (truncated, free surface)
            [Abc1, Bbc1] = obj.subD(1).BC0(size(Age,2)-1);
            % BC (free slip)
            [Abc2, Bbc2] = obj.subD(end).BChf(size(Age,2)-1);
            A = [Age; Abc1; Abc2];
            B = [Bge; Bbc1; Bbc2];
        end
        function [A, B] = makeABs(obj)
            % Governing equation
            [Age, Bge] = obj.subD(1).match(obj.subD);
            % BC (truncated, free surface)
            [Abc1, Bbc1] = obj.subD(1).BC0s(size(Age,2)-1);
            % BC (free slip)
            [Abc2, Bbc2] = obj.subD(end).BChe(size(Age,2)-1);
            A = [Age(); Abc1; Abc2];
            B = [Bge; Bbc1; Bbc2];
        end
        % Set velocity profile (baseflow, invbf)
        setbaseflow(obj,bf);
        % Construct and modify subdomains with specified DD methods
        function setsubd(obj,init,funcN,addvar)
            [Na, arr] = funcN(obj, init, addvar);
            % Create subdomains according to (N, arr)
            flg = strcmpi(init,'init');
            for j = 1:length(Na)
                if flg || j > length(obj.subD)
                    obj.subD(j) = obj.subDclass(Na(j),arr(j),arr(j+1),obj);
                else
                    obj.subD(j).chgL(Na(j),arr(j),arr(j+1));
                end
            end
            % Remove redundant subdomains
            if length(Na) < length(obj.subD)
                obj.subD = obj.subD(1:length(Na));
            end
        end
    end
end